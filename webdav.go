// Copyright 2015 Matthew Holt
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package webdav implements a WebDAV server handler module for Caddy.
//
// Derived from work by Henrique Dias: https://github.com/hacdias/caddy-webdav
package webdav

import (
	"context"
	"errors"
	"io"
	"io/fs"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/caddyserver/caddy/v2"
	"github.com/caddyserver/caddy/v2/caddyconfig/caddyfile"
	"github.com/caddyserver/caddy/v2/modules/caddyhttp"
	"go.uber.org/zap"
	"golang.org/x/net/webdav"
)

func init() {
	caddy.RegisterModule(WebDAV{})
}

// File-based ETag calculation copied from caddy/modules/caddyhttp/fileserver/staticfiles.go.
//
// If `etag_file_extensions` for file_server is NOT set, file_server will
// use the function below to calculate ETags, which concatenates encoded
// file modification timestamp and encoded file size.
//
// Sidecar ETag files are not suitable for webdav's case, in which the data
// can be modified by clients, without touching the sidecar files. So
// `etag_file_extensions` should never be set if file_server handles GET
// requests from webdav clients.
//
// Note that x/net/webdav uses Apache http 2.4 web server's method and the
// only difference is the number format: file_server uses 36 as base,
// webdav uses 16 as base.
func calculateEtag(d os.FileInfo) string {
	mtime := d.ModTime()
	if mtimeUnix := mtime.Unix(); mtimeUnix == 0 || mtimeUnix == 1 {
		return "" // not useful anyway; see issue caddy#5548
	}
	var sb strings.Builder
	sb.WriteRune('"')
	sb.WriteString(strconv.FormatInt(mtime.UnixNano(), 36))
	sb.WriteString(strconv.FormatInt(d.Size(), 36))
	sb.WriteRune('"')
	return sb.String()
}

// WebDAV implements an HTTP handler for responding to WebDAV clients.
type WebDAV struct {
	// The root directory out of which to serve files. If
	// not specified, `{http.vars.root}` will be used if
	// set; otherwise, the current directory is assumed.
	// Accepts placeholders.
	Root string `json:"root,omitempty"`

	// The base path prefix used to access the WebDAV share.
	// Should be used if one more more matchers are used with the
	// webdav directive and it's needed to let the webdav share know
	// what the request base path will be.
	// For example:
	// webdav /some/path/match/* {
	//   root /path
	//   prefix /some/path/match
	// }
	// Accepts placeholders.
	Prefix string `json:"prefix,omitempty"`

	lockSystem webdav.LockSystem
	logger     *zap.Logger
}

// CaddyModule returns the Caddy module information.
func (WebDAV) CaddyModule() caddy.ModuleInfo {
	return caddy.ModuleInfo{
		ID:  "http.handlers.webdav",
		New: func() caddy.Module { return new(WebDAV) },
	}
}

// Provision sets up the module.
func (wd *WebDAV) Provision(ctx caddy.Context) error {
	wd.logger = ctx.Logger(wd)

	wd.lockSystem = webdav.NewMemLS()
	if wd.Root == "" {
		wd.Root = "{http.vars.root}"
	}

	return nil
}

// os.FileInfo wrapper to provide webdav.ETager implementation.
// This is particularly useful when file_server is used to serve listings and
// handle download requests. With this configuration, if the ETags return by
// HEAD methods don't match those generated by file_server, some clients may
// experience http 412 errors returned by file_server, due to mismatched ETag
// sent through "If-Match".
type WebDAVFileInfo struct{ os.FileInfo }

func (d WebDAVFileInfo) ETag(ctx context.Context) (string, error) {
	return calculateEtag(d.FileInfo), nil
}

// webdav.File wrapper to make it able to return WebDAVFileInfo other than plain os.FileInfo.
type WebDAVFileWrapper struct{ webdav.File }

func (fw *WebDAVFileWrapper) Stat() (os.FileInfo, error) {
	fi, err := fw.File.Stat()
	if err != nil {
		return fi, err
	}
	return WebDAVFileInfo{FileInfo: fi}, nil
}

// webdav.Dir wrapper to return properly wrapped structs to override the ETag calculation.
type WebDAVDirFileSystemWrapper struct{ webdav.Dir }

func (d WebDAVDirFileSystemWrapper) OpenFile(ctx context.Context, name string, flag int, perm os.FileMode) (webdav.File, error) {
	f, err := d.Dir.OpenFile(ctx, name, flag, perm)
	if err != nil {
		return f, err
	}
	return &WebDAVFileWrapper{File: f}, err
}

func (d WebDAVDirFileSystemWrapper) Stat(ctx context.Context, name string) (os.FileInfo, error) {
	stat, err := d.Dir.Stat(ctx, name)
	if err != nil {
		return stat, err
	}
	return WebDAVFileInfo{FileInfo: stat}, err
}

func (wd WebDAV) ServeHTTP(w http.ResponseWriter, r *http.Request, next caddyhttp.Handler) error {
	// TODO: integrate with caddy 2's existing auth features to enforce read-only?
	// read methods: GET, HEAD, OPTIONS
	// write methods: POST, PUT, PATCH, DELETE, COPY, MKCOL, MOVE, PROPPATCH

	repl := r.Context().Value(caddy.ReplacerCtxKey).(*caddy.Replacer)
	root := repl.ReplaceAll(wd.Root, ".")
	prefix := repl.ReplaceAll(wd.Prefix, "")

	wdHandler := webdav.Handler{
		Prefix:     prefix,
		FileSystem: WebDAVDirFileSystemWrapper{Dir: webdav.Dir(root)},
		LockSystem: wd.lockSystem,
		Logger: func(req *http.Request, err error) {
			if err == nil {
				return
			}
			// ignore errors about non-existing files
			if errors.Is(err, fs.ErrNotExist) {
				return
			}
			// log webdav request errors at debug level
			if errors.Is(err, webdav.ErrConfirmationFailed) ||
				errors.Is(err, webdav.ErrForbidden) ||
				errors.Is(err, webdav.ErrLocked) ||
				errors.Is(err, webdav.ErrNoSuchLock) {
				wd.logger.Debug("webdav request error",
					zap.Error(err),
					zap.Object("request", caddyhttp.LoggableHTTPRequest{Request: req}),
				)
				return
			}

			wd.logger.Error("internal handler error",
				zap.Error(err),
				zap.Object("request", caddyhttp.LoggableHTTPRequest{Request: req}),
			)
		},
	}

	// Excerpt from RFC4918, section 9.4:
	//
	//     GET, when applied to a collection, may return the contents of an
	//     "index.html" resource, a human-readable view of the contents of
	//     the collection, or something else altogether.
	//
	// GET and HEAD, when applied to a collection, will behave the same as PROPFIND method.
	if r.Method == http.MethodGet || r.Method == http.MethodHead {
		info, err := wdHandler.FileSystem.Stat(context.TODO(), r.URL.Path)
		if err == nil && info.IsDir() {
			r.Method = "PROPFIND"
			if r.Header.Get("Depth") == "" {
				r.Header.Add("Depth", "1")
			}
		}
	}

	if r.Method == http.MethodHead {
		w = emptyBodyResponseWriter{w}
	}

	if r.Method == http.MethodGet {
		w = getFileResponseWriter{w}
	}

	wdHandler.ServeHTTP(w, r)

	return nil
}

// emptyBodyResponseWriter is a response writer that does not write a body.
type emptyBodyResponseWriter struct{ http.ResponseWriter }

func (w emptyBodyResponseWriter) Write(data []byte) (int, error) { return 0, nil }

// getFileResponseWriter is a helper to unwrap embedded webdav.File(actually *os.File) in WebDAVFileWrapper
//
// Actual sendfile syscall caller only accepts *os.File and *io.LimitedReader with
// *os.File as underlying reader.
// When handling GET requests, webdav eventually passes the file handle to
// http.ServeContent, which wraps the handle into *io.LimitedReader and calls
// io.CopyN. Here the file handle is the underlying reader.
//
// In our case, the file handle is wrapped by WebDAVFileWrapper and the wrapper
// becomes the underlying reader. To make sendfile work, the embedded *os.File
// should be promoted.
// Since our wrapper is contained in *io.LimitedReader resulting wrapper's
// WriteTo masked, the only suitable place to implement the unwrapping logic
// is in ReadFrom for ResponseWriter which we have control of.
type getFileResponseWriter struct{ http.ResponseWriter }

func (w getFileResponseWriter) ReadFrom(r io.Reader) (int64, error) {
	// check ReaderFrom
	rr, _ := w.ResponseWriter.(io.ReaderFrom)
	// *io.LimitedReader is used by http.ServeContent
	if lr, ok := r.(*io.LimitedReader); ok {
		// promote the embedded *os.File
		if df, ok := lr.R.(*WebDAVFileWrapper); ok {
			if df != nil {
				lr.R = df.File
			}
		}
	}
	if rr != nil {
		return rr.ReadFrom(r)
	}
	return io.Copy(w.ResponseWriter, r)
}

// Interface guards
var (
	_ caddyhttp.MiddlewareHandler = (*WebDAV)(nil)
	_ caddyfile.Unmarshaler       = (*WebDAV)(nil)
	_ webdav.ETager               = (*WebDAVFileInfo)(nil)
	_ webdav.File                 = (*WebDAVFileWrapper)(nil)
	_ webdav.FileSystem           = (*WebDAVDirFileSystemWrapper)(nil)

	// Actual sendfile syscall caller only accepts *os.File and *io.LimitedReader with
	// *os.File as underlying reader. Therefore *os.File has to be extracted from its
	// wrapper to retain the optimization. The extraction is implemented in ReadFrom.
	// Read more explaination at the definition of getFileResponseWriter.
	_ io.ReaderFrom = (*getFileResponseWriter)(nil)
)
